<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `MaybeUninit` union in crate `maybe_uninit`."><meta name="keywords" content="rust, rustlang, rust-lang, MaybeUninit"><title>maybe_uninit::MaybeUninit - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../dark.css"><link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle"><script src="../storage.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="shortcut icon" href="../favicon.ico"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc union"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../maybe_uninit/index.html'><div class='logo-container'><img src='../rust-logo.png' alt='logo'></div></a><p class='location'>Union MaybeUninit</p><div class="sidebar-elems"><div class="block items"><a class="sidebar-title" href="#methods">Methods</a><div class="sidebar-links"><a href="#method.as_mut_ptr">as_mut_ptr</a><a href="#method.as_ptr">as_ptr</a><a href="#method.assume_init">assume_init</a><a href="#method.first_ptr">first_ptr</a><a href="#method.first_ptr_mut">first_ptr_mut</a><a href="#method.get_mut">get_mut</a><a href="#method.get_ref">get_ref</a><a href="#method.new">new</a><a href="#method.read">read</a><a href="#method.slice_get_mut">slice_get_mut</a><a href="#method.slice_get_ref">slice_get_ref</a><a href="#method.uninit">uninit</a><a href="#method.uninit_array">uninit_array</a><a href="#method.write">write</a><a href="#method.zeroed">zeroed</a></div><a class="sidebar-title" href="#implementations">Trait Implementations</a><div class="sidebar-links"><a href="#impl-Clone">Clone</a><a href="#impl-Copy">Copy</a><a href="#impl-Debug">Debug</a></div><a class="sidebar-title" href="#synthetic-implementations">Auto Trait Implementations</a><div class="sidebar-links"><a href="#impl-Send">Send</a><a href="#impl-Sync">Sync</a><a href="#impl-Unpin">Unpin</a></div><a class="sidebar-title" href="#blanket-implementations">Blanket Implementations</a><div class="sidebar-links"><a href="#impl-Any">Any</a><a href="#impl-Borrow%3CT%3E">Borrow&lt;T&gt;</a><a href="#impl-BorrowMut%3CT%3E">BorrowMut&lt;T&gt;</a><a href="#impl-From%3CT%3E">From&lt;T&gt;</a><a href="#impl-Into%3CU%3E">Into&lt;U&gt;</a><a href="#impl-TryFrom%3CU%3E">TryFrom&lt;U&gt;</a><a href="#impl-TryInto%3CU%3E">TryInto&lt;U&gt;</a></div></div><p class='location'><a href='index.html'>maybe_uninit</a></p><script>window.sidebarCurrent = {name: 'MaybeUninit', ty: 'union', relpath: ''};</script><script defer src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../theme.js"></script><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><a id="settings-menu" href="../settings.html"><img src="../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class='fqn'><span class='out-of-band'><span class='since' title='Stable since Rust version 1.36.0'>1.36.0</span><span id='render-detail'><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class='inner'>&#x2212;</span>]</a></span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/mem/maybe_uninit.rs.html#223-226' title='goto source code'>[src]</a></span><span class='in-band'>Union <a href='index.html'>maybe_uninit</a>::<wbr><a class="union" href=''>MaybeUninit</a></span></h1><div class="docblock type-decl hidden-by-usual-hider"><pre class='rust union'><span class="docblock attributes top-attr">#[lang = "maybe_uninit"]
#[repr(transparent)]
</span>pub union MaybeUninit&lt;T&gt; {
    // some fields omitted
}</pre></div><div class='docblock'><p>A wrapper type to construct uninitialized instances of <code>T</code>.</p>
<h1 id="initialization-invariant" class="section-header"><a href="#initialization-invariant">Initialization invariant</a></h1>
<p>The compiler, in general, assumes that a variable is properly initialized
according to the requirements of the variable's type. For example, a variable of
reference type must be aligned and non-NULL. This is an invariant that must
<em>always</em> be upheld, even in unsafe code. As a consequence, zero-initializing a
variable of reference type causes instantaneous <a href="../../reference/behavior-considered-undefined.html">undefined behavior</a>,
no matter whether that reference ever gets used to access memory:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">mem</span>::{<span class="self">self</span>, <span class="ident">MaybeUninit</span>};

<span class="kw">let</span> <span class="ident">x</span>: <span class="kw-2">&amp;</span><span class="ident">i32</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="ident">mem</span>::<span class="ident">zeroed</span>() }; <span class="comment">// undefined behavior!</span>
<span class="comment">// The equivalent code with `MaybeUninit&lt;&amp;i32&gt;`:</span>
<span class="kw">let</span> <span class="ident">x</span>: <span class="kw-2">&amp;</span><span class="ident">i32</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="ident">MaybeUninit</span>::<span class="ident">zeroed</span>().<span class="ident">assume_init</span>() }; <span class="comment">// undefined behavior!</span></pre></div>
<p>This is exploited by the compiler for various optimizations, such as eliding
run-time checks and optimizing <code>enum</code> layout.</p>
<p>Similarly, entirely uninitialized memory may have any content, while a <code>bool</code> must
always be <code>true</code> or <code>false</code>. Hence, creating an uninitialized <code>bool</code> is undefined behavior:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">mem</span>::{<span class="self">self</span>, <span class="ident">MaybeUninit</span>};

<span class="kw">let</span> <span class="ident">b</span>: <span class="ident">bool</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="ident">mem</span>::<span class="ident">uninitialized</span>() }; <span class="comment">// undefined behavior!</span>
<span class="comment">// The equivalent code with `MaybeUninit&lt;bool&gt;`:</span>
<span class="kw">let</span> <span class="ident">b</span>: <span class="ident">bool</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="ident">MaybeUninit</span>::<span class="ident">uninit</span>().<span class="ident">assume_init</span>() }; <span class="comment">// undefined behavior!</span></pre></div>
<p>Moreover, uninitialized memory is special in that the compiler knows that
it does not have a fixed value. This makes it undefined behavior to have
uninitialized data in a variable even if that variable has an integer type,
which otherwise can hold any <em>fixed</em> bit pattern:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">mem</span>::{<span class="self">self</span>, <span class="ident">MaybeUninit</span>};

<span class="kw">let</span> <span class="ident">x</span>: <span class="ident">i32</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="ident">mem</span>::<span class="ident">uninitialized</span>() }; <span class="comment">// undefined behavior!</span>
<span class="comment">// The equivalent code with `MaybeUninit&lt;i32&gt;`:</span>
<span class="kw">let</span> <span class="ident">x</span>: <span class="ident">i32</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="ident">MaybeUninit</span>::<span class="ident">uninit</span>().<span class="ident">assume_init</span>() }; <span class="comment">// undefined behavior!</span></pre></div>
<p>(Notice that the rules around uninitialized integers are not finalized yet, but
until they are, it is advisable to avoid them.)</p>
<p>On top of that, remember that most types have additional invariants beyond merely
being considered initialized at the type level. For example, a <code>1</code>-initialized <a href="../../std/vec/struct.Vec.html"><code>Vec&lt;T&gt;</code></a>
is considered initialized (under the current implementation; this does not constitute
a stable guarantee) because the only requirement the compiler knows about it
is that the data pointer must be non-null. Creating such a <code>Vec&lt;T&gt;</code> does not cause
<em>immediate</em> undefined behavior, but will cause undefined behavior with most
safe operations (including dropping it).</p>
<h1 id="examples" class="section-header"><a href="#examples">Examples</a></h1>
<p><code>MaybeUninit&lt;T&gt;</code> serves to enable unsafe code to deal with uninitialized data.
It is a signal to the compiler indicating that the data here might <em>not</em>
be initialized:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">mem</span>::<span class="ident">MaybeUninit</span>;

<span class="comment">// Create an explicitly uninitialized reference. The compiler knows that data inside</span>
<span class="comment">// a `MaybeUninit&lt;T&gt;` may be invalid, and hence this is not UB:</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">x</span> <span class="op">=</span> <span class="ident">MaybeUninit</span>::<span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">i32</span><span class="op">&gt;</span>::<span class="ident">uninit</span>();
<span class="comment">// Set it to a valid value.</span>
<span class="kw">unsafe</span> { <span class="ident">x</span>.<span class="ident">as_mut_ptr</span>().<span class="ident">write</span>(<span class="kw-2">&amp;</span><span class="number">0</span>); }
<span class="comment">// Extract the initialized data -- this is only allowed *after* properly</span>
<span class="comment">// initializing `x`!</span>
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="ident">x</span>.<span class="ident">assume_init</span>() };</pre></div>
<p>The compiler then knows to not make any incorrect assumptions or optimizations on this code.</p>
<p>You can think of <code>MaybeUninit&lt;T&gt;</code> as being a bit like <code>Option&lt;T&gt;</code> but without
any of the run-time tracking and without any of the safety checks.</p>
<h2 id="out-pointers" class="section-header"><a href="#out-pointers">out-pointers</a></h2>
<p>You can use <code>MaybeUninit&lt;T&gt;</code> to implement &quot;out-pointers&quot;: instead of returning data
from a function, pass it a pointer to some (uninitialized) memory to put the
result into. This can be useful when it is important for the caller to control
how the memory the result is stored in gets allocated, and you want to avoid
unnecessary moves.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">mem</span>::<span class="ident">MaybeUninit</span>;

<span class="kw">unsafe</span> <span class="kw">fn</span> <span class="ident">make_vec</span>(<span class="ident">out</span>: <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span>) {
    <span class="comment">// `write` does not drop the old contents, which is important.</span>
    <span class="ident">out</span>.<span class="ident">write</span>(<span class="macro">vec</span><span class="macro">!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);
}

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">v</span> <span class="op">=</span> <span class="ident">MaybeUninit</span>::<span class="ident">uninit</span>();
<span class="kw">unsafe</span> { <span class="ident">make_vec</span>(<span class="ident">v</span>.<span class="ident">as_mut_ptr</span>()); }
<span class="comment">// Now we know `v` is initialized! This also makes sure the vector gets</span>
<span class="comment">// properly dropped.</span>
<span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="ident">v</span>.<span class="ident">assume_init</span>() };
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="kw-2">&amp;</span><span class="ident">v</span>, <span class="kw-2">&amp;</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</pre></div>
<h2 id="initializing-an-array-element-by-element" class="section-header"><a href="#initializing-an-array-element-by-element">Initializing an array element-by-element</a></h2>
<p><code>MaybeUninit&lt;T&gt;</code> can be used to initialize a large array element-by-element:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">mem</span>::{<span class="self">self</span>, <span class="ident">MaybeUninit</span>};

<span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> {
    <span class="comment">// Create an uninitialized array of `MaybeUninit`. The `assume_init` is</span>
    <span class="comment">// safe because the type we are claiming to have initialized here is a</span>
    <span class="comment">// bunch of `MaybeUninit`s, which do not require initialization.</span>
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span>: [<span class="ident">MaybeUninit</span><span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span><span class="op">&gt;</span>; <span class="number">1000</span>] <span class="op">=</span> <span class="kw">unsafe</span> {
        <span class="ident">MaybeUninit</span>::<span class="ident">uninit</span>().<span class="ident">assume_init</span>()
    };

    <span class="comment">// Dropping a `MaybeUninit` does nothing. Thus using raw pointer</span>
    <span class="comment">// assignment instead of `ptr::write` does not cause the old</span>
    <span class="comment">// uninitialized value to be dropped. Also if there is a panic during</span>
    <span class="comment">// this loop, we have a memory leak, but there is no memory safety</span>
    <span class="comment">// issue.</span>
    <span class="kw">for</span> <span class="ident">elem</span> <span class="kw">in</span> <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">data</span>[..] {
        <span class="kw-2">*</span><span class="ident">elem</span> <span class="op">=</span> <span class="ident">MaybeUninit</span>::<span class="ident">new</span>(<span class="macro">vec</span><span class="macro">!</span>[<span class="number">42</span>]);
    }

    <span class="comment">// Everything is initialized. Transmute the array to the</span>
    <span class="comment">// initialized type.</span>
    <span class="kw">unsafe</span> { <span class="ident">mem</span>::<span class="ident">transmute</span>::<span class="op">&lt;</span><span class="kw">_</span>, [<span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span>; <span class="number">1000</span>]<span class="op">&gt;</span>(<span class="ident">data</span>) }
};

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="kw-2">&amp;</span><span class="ident">data</span>[<span class="number">0</span>], <span class="kw-2">&amp;</span>[<span class="number">42</span>]);</pre></div>
<p>You can also work with partially initialized arrays, which could
be found in low-level datastructures.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">mem</span>::<span class="ident">MaybeUninit</span>;
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">ptr</span>;

<span class="comment">// Create an uninitialized array of `MaybeUninit`. The `assume_init` is</span>
<span class="comment">// safe because the type we are claiming to have initialized here is a</span>
<span class="comment">// bunch of `MaybeUninit`s, which do not require initialization.</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span>: [<span class="ident">MaybeUninit</span><span class="op">&lt;</span><span class="ident">String</span><span class="op">&gt;</span>; <span class="number">1000</span>] <span class="op">=</span> <span class="kw">unsafe</span> { <span class="ident">MaybeUninit</span>::<span class="ident">uninit</span>().<span class="ident">assume_init</span>() };
<span class="comment">// Count the number of elements we have assigned.</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data_len</span>: <span class="ident">usize</span> <span class="op">=</span> <span class="number">0</span>;

<span class="kw">for</span> <span class="ident">elem</span> <span class="kw">in</span> <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">data</span>[<span class="number">0</span>..<span class="number">500</span>] {
    <span class="kw-2">*</span><span class="ident">elem</span> <span class="op">=</span> <span class="ident">MaybeUninit</span>::<span class="ident">new</span>(<span class="ident">String</span>::<span class="ident">from</span>(<span class="string">&quot;hello&quot;</span>));
    <span class="ident">data_len</span> <span class="op">+</span><span class="op">=</span> <span class="number">1</span>;
}

<span class="comment">// For each item in the array, drop if we allocated it.</span>
<span class="kw">for</span> <span class="ident">elem</span> <span class="kw">in</span> <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">data</span>[<span class="number">0</span>..<span class="ident">data_len</span>] {
    <span class="kw">unsafe</span> { <span class="ident">ptr</span>::<span class="ident">drop_in_place</span>(<span class="ident">elem</span>.<span class="ident">as_mut_ptr</span>()); }
}</pre></div>
<h2 id="initializing-a-struct-field-by-field" class="section-header"><a href="#initializing-a-struct-field-by-field">Initializing a struct field-by-field</a></h2>
<p>There is currently no supported way to create a raw pointer or reference
to a field of a struct inside <code>MaybeUninit&lt;Struct&gt;</code>. That means it is not possible
to create a struct by calling <code>MaybeUninit::uninit::&lt;Struct&gt;()</code> and then writing
to its fields.</p>
<h1 id="layout" class="section-header"><a href="#layout">Layout</a></h1>
<p><code>MaybeUninit&lt;T&gt;</code> is guaranteed to have the same size, alignment, and ABI as <code>T</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">mem</span>::{<span class="ident">MaybeUninit</span>, <span class="ident">size_of</span>, <span class="ident">align_of</span>};
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">size_of</span>::<span class="op">&lt;</span><span class="ident">MaybeUninit</span><span class="op">&lt;</span><span class="ident">u64</span><span class="op">&gt;</span><span class="op">&gt;</span>(), <span class="ident">size_of</span>::<span class="op">&lt;</span><span class="ident">u64</span><span class="op">&gt;</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">align_of</span>::<span class="op">&lt;</span><span class="ident">MaybeUninit</span><span class="op">&lt;</span><span class="ident">u64</span><span class="op">&gt;</span><span class="op">&gt;</span>(), <span class="ident">align_of</span>::<span class="op">&lt;</span><span class="ident">u64</span><span class="op">&gt;</span>());</pre></div>
<p>However remember that a type <em>containing</em> a <code>MaybeUninit&lt;T&gt;</code> is not necessarily the same
layout; Rust does not in general guarantee that the fields of a <code>Foo&lt;T&gt;</code> have the same order as
a <code>Foo&lt;U&gt;</code> even if <code>T</code> and <code>U</code> have the same size and alignment. Furthermore because any bit
value is valid for a <code>MaybeUninit&lt;T&gt;</code> the compiler can't apply non-zero/niche-filling
optimizations, potentially resulting in a larger size:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">size_of</span>::<span class="op">&lt;</span><span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">bool</span><span class="op">&gt;</span><span class="op">&gt;</span>(), <span class="number">1</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">size_of</span>::<span class="op">&lt;</span><span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">MaybeUninit</span><span class="op">&lt;</span><span class="ident">bool</span><span class="op">&gt;</span><span class="op">&gt;</span><span class="op">&gt;</span>(), <span class="number">2</span>);</pre></div>
<p>If <code>T</code> is FFI-safe, then so is <code>MaybeUninit&lt;T&gt;</code>.</p>
<p>While <code>MaybeUninit</code> is <code>#[repr(transparent)]</code> (indicating it guarantees the same size,
alignment, and ABI as <code>T</code>), this does <em>not</em> change any of the previous caveats. <code>Option&lt;T&gt;</code> and
<code>Option&lt;MaybeUninit&lt;T&gt;&gt;</code> may still have different sizes, and types containing a field of type
<code>T</code> may be laid out (and sized) differently than if that field were <code>MaybeUninit&lt;T&gt;</code>.
<code>MaybeUninit</code> is a union type, and <code>#[repr(transparent)]</code> on unions is unstable (see <a href="https://github.com/rust-lang/rust/issues/60405">the
tracking issue</a>). Over time, the exact
guarantees of <code>#[repr(transparent)]</code> on unions may evolve, and <code>MaybeUninit</code> may or may not
remain <code>#[repr(transparent)]</code>. That said, <code>MaybeUninit&lt;T&gt;</code> will <em>always</em> guarantee that it has
the same size, alignment, and ABI as <code>T</code>; it's just that the way <code>MaybeUninit</code> implements that
guarantee may evolve.</p>
</div><h2 id='methods' class='small-section-header'>Methods<a href='#methods' class='anchor'></a></h2><h3 id='impl' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="union" href="../maybe_uninit/union.MaybeUninit.html" title="union maybe_uninit::MaybeUninit">MaybeUninit</a>&lt;T&gt;</code><a href='#impl' class='anchor'></a><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/mem/maybe_uninit.rs.html#244-785' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.new' class="method"><code id='new.v'>pub const fn <a href='#method.new' class='fnname'>new</a>(val: T) -&gt; <a class="union" href="../maybe_uninit/union.MaybeUninit.html" title="union maybe_uninit::MaybeUninit">MaybeUninit</a>&lt;T&gt;</code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/mem/maybe_uninit.rs.html#255-257' title='goto source code'>[src]</a></h4><div class='docblock'><p>Creates a new <code>MaybeUninit&lt;T&gt;</code> initialized with the given value.
It is safe to call <a href="#method.assume_init"><code>assume_init</code></a> on the return value of this function.</p>
<p>Note that dropping a <code>MaybeUninit&lt;T&gt;</code> will never call <code>T</code>'s drop code.
It is your responsibility to make sure <code>T</code> gets dropped if it got initialized.</p>
</div><h4 id='method.uninit' class="method"><code id='uninit.v'>pub const fn <a href='#method.uninit' class='fnname'>uninit</a>() -&gt; <a class="union" href="../maybe_uninit/union.MaybeUninit.html" title="union maybe_uninit::MaybeUninit">MaybeUninit</a>&lt;T&gt;</code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/mem/maybe_uninit.rs.html#271-273' title='goto source code'>[src]</a></h4><div class='docblock'><p>Creates a new <code>MaybeUninit&lt;T&gt;</code> in an uninitialized state.</p>
<p>Note that dropping a <code>MaybeUninit&lt;T&gt;</code> will never call <code>T</code>'s drop code.
It is your responsibility to make sure <code>T</code> gets dropped if it got initialized.</p>
<p>See the <a href="union.MaybeUninit.html">type-level documentation</a> for some examples.</p>
</div><h4 id='method.uninit_array' class="method"><code id='uninit_array.v'>pub fn <a href='#method.uninit_array' class='fnname'>uninit_array</a>&lt;const LEN:&nbsp;usize&gt;() -&gt; [<a class="union" href="../maybe_uninit/union.MaybeUninit.html" title="union maybe_uninit::MaybeUninit">MaybeUninit</a>&lt;T&gt;; LEN]</code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/mem/maybe_uninit.rs.html#306-308' title='goto source code'>[src]</a></h4><div class='stability'><div class='stab unstable'><span class='emoji'>🔬</span> This is a nightly-only experimental API. (<code>maybe_uninit_uninit_array</code>)</div></div><div class='docblock'><p>Create a new array of <code>MaybeUninit&lt;T&gt;</code> items, in an uninitialized state.</p>
<p>Note: in a future Rust version this method may become unnecessary
when array literal syntax allows
<a href="https://github.com/rust-lang/rust/issues/49147">repeating const expressions</a>.
The example below could then use <code>let mut buf = [MaybeUninit::&lt;u8&gt;::uninit(); 32];</code>.</p>
<h1 id="examples-1" class="section-header"><a href="#examples-1">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="attribute">#![<span class="ident">feature</span>(<span class="ident">maybe_uninit_uninit_array</span>, <span class="ident">maybe_uninit_extra</span>, <span class="ident">maybe_uninit_slice_assume_init</span>)]</span>

<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">mem</span>::<span class="ident">MaybeUninit</span>;

<span class="kw">extern</span> <span class="string">&quot;C&quot;</span> {
    <span class="kw">fn</span> <span class="ident">read_into_buffer</span>(<span class="ident">ptr</span>: <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">u8</span>, <span class="ident">max_len</span>: <span class="ident">usize</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">usize</span>;
}

<span class="doccomment">/// Returns a (possibly smaller) slice of data that was actually read</span>
<span class="kw">fn</span> <span class="ident">read</span>(<span class="ident">buf</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> [<span class="ident">MaybeUninit</span><span class="op">&lt;</span><span class="ident">u8</span><span class="op">&gt;</span>]) <span class="op">-</span><span class="op">&gt;</span> <span class="kw-2">&amp;</span>[<span class="ident">u8</span>] {
    <span class="kw">unsafe</span> {
        <span class="kw">let</span> <span class="ident">len</span> <span class="op">=</span> <span class="ident">read_into_buffer</span>(<span class="ident">buf</span>.<span class="ident">as_mut_ptr</span>() <span class="kw">as</span> <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">u8</span>, <span class="ident">buf</span>.<span class="ident">len</span>());
        <span class="ident">MaybeUninit</span>::<span class="ident">slice_get_ref</span>(<span class="kw-2">&amp;</span><span class="ident">buf</span>[..<span class="ident">len</span>])
    }
}

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">buf</span>: [<span class="ident">MaybeUninit</span><span class="op">&lt;</span><span class="ident">u8</span><span class="op">&gt;</span>; <span class="number">32</span>] <span class="op">=</span> <span class="ident">MaybeUninit</span>::<span class="ident">uninit_array</span>();
<span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="ident">read</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">buf</span>);</pre></div>
</div><h4 id='associatedconstant.UNINIT' class="associatedconstant"><code id='UNINIT.v'>pub const <a href='#associatedconstant.UNINIT' class="constant"><b>UNINIT</b></a>: <a class="union" href="../maybe_uninit/union.MaybeUninit.html" title="union maybe_uninit::MaybeUninit">MaybeUninit</a>&lt;T&gt;</code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/mem/maybe_uninit.rs.html#316' title='goto source code'>[src]</a></h4><div class='stability'><div class='stab unstable'><details><summary><span class='emoji'>🔬</span> This is a nightly-only experimental API. (<code>internal_uninit_const</code>)</summary><p>hack to work around promotability</p>
</details></div></div><div class='docblock'><p>A promotable constant, equivalent to <code>uninit()</code>.</p>
</div><h4 id='method.zeroed' class="method"><code id='zeroed.v'>pub fn <a href='#method.zeroed' class='fnname'>zeroed</a>() -&gt; <a class="union" href="../maybe_uninit/union.MaybeUninit.html" title="union maybe_uninit::MaybeUninit">MaybeUninit</a>&lt;T&gt;</code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/mem/maybe_uninit.rs.html#356-362' title='goto source code'>[src]</a></h4><div class='docblock'><p>Creates a new <code>MaybeUninit&lt;T&gt;</code> in an uninitialized state, with the memory being
filled with <code>0</code> bytes. It depends on <code>T</code> whether that already makes for
proper initialization. For example, <code>MaybeUninit&lt;usize&gt;::zeroed()</code> is initialized,
but <code>MaybeUninit&lt;&amp;'static i32&gt;::zeroed()</code> is not because references must not
be null.</p>
<p>Note that dropping a <code>MaybeUninit&lt;T&gt;</code> will never call <code>T</code>'s drop code.
It is your responsibility to make sure <code>T</code> gets dropped if it got initialized.</p>
<h1 id="example" class="section-header"><a href="#example">Example</a></h1>
<p>Correct usage of this function: initializing a struct with zero, where all
fields of the struct can hold the bit-pattern 0 as a valid value.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">mem</span>::<span class="ident">MaybeUninit</span>;

<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="ident">MaybeUninit</span>::<span class="op">&lt;</span>(<span class="ident">u8</span>, <span class="ident">bool</span>)<span class="op">&gt;</span>::<span class="ident">zeroed</span>();
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="ident">x</span>.<span class="ident">assume_init</span>() };
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">x</span>, (<span class="number">0</span>, <span class="bool-val">false</span>));</pre></div>
<p><em>Incorrect</em> usage of this function: initializing a struct with zero, where some fields
cannot hold 0 as a valid value.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">mem</span>::<span class="ident">MaybeUninit</span>;

<span class="kw">enum</span> <span class="ident">NotZero</span> { <span class="ident">One</span> <span class="op">=</span> <span class="number">1</span>, <span class="ident">Two</span> <span class="op">=</span> <span class="number">2</span> };

<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="ident">MaybeUninit</span>::<span class="op">&lt;</span>(<span class="ident">u8</span>, <span class="ident">NotZero</span>)<span class="op">&gt;</span>::<span class="ident">zeroed</span>();
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="ident">x</span>.<span class="ident">assume_init</span>() };
<span class="comment">// Inside a pair, we create a `NotZero` that does not have a valid discriminant.</span>
<span class="comment">// This is undefined behavior.</span></pre></div>
</div><h4 id='method.write' class="method"><code id='write.v'>pub fn <a href='#method.write' class='fnname'>write</a>(&amp;mut self, val: T) -&gt; &amp;mut T</code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/mem/maybe_uninit.rs.html#370-375' title='goto source code'>[src]</a></h4><div class='stability'><div class='stab unstable'><span class='emoji'>🔬</span> This is a nightly-only experimental API. (<code>maybe_uninit_extra</code>)</div></div><div class='docblock'><p>Sets the value of the <code>MaybeUninit&lt;T&gt;</code>. This overwrites any previous value
without dropping it, so be careful not to use this twice unless you want to
skip running the destructor. For your convenience, this also returns a mutable
reference to the (now safely initialized) contents of <code>self</code>.</p>
</div><h4 id='method.as_ptr' class="method"><code id='as_ptr.v'>pub fn <a href='#method.as_ptr' class='fnname'>as_ptr</a>(&amp;self) -&gt; *const T</code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/mem/maybe_uninit.rs.html#410-412' title='goto source code'>[src]</a></h4><div class='docblock'><p>Gets a pointer to the contained value. Reading from this pointer or turning it
into a reference is undefined behavior unless the <code>MaybeUninit&lt;T&gt;</code> is initialized.
Writing to memory that this pointer (non-transitively) points to is undefined behavior
(except inside an <code>UnsafeCell&lt;T&gt;</code>).</p>
<h1 id="examples-2" class="section-header"><a href="#examples-2">Examples</a></h1>
<p>Correct usage of this method:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">mem</span>::<span class="ident">MaybeUninit</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">x</span> <span class="op">=</span> <span class="ident">MaybeUninit</span>::<span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span><span class="op">&gt;</span>::<span class="ident">uninit</span>();
<span class="kw">unsafe</span> { <span class="ident">x</span>.<span class="ident">as_mut_ptr</span>().<span class="ident">write</span>(<span class="macro">vec</span><span class="macro">!</span>[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]); }
<span class="comment">// Create a reference into the `MaybeUninit&lt;T&gt;`. This is okay because we initialized it.</span>
<span class="kw">let</span> <span class="ident">x_vec</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="kw-2">&amp;</span><span class="kw-2">*</span><span class="ident">x</span>.<span class="ident">as_ptr</span>() };
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">x_vec</span>.<span class="ident">len</span>(), <span class="number">3</span>);</pre></div>
<p><em>Incorrect</em> usage of this method:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">mem</span>::<span class="ident">MaybeUninit</span>;

<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="ident">MaybeUninit</span>::<span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span><span class="op">&gt;</span>::<span class="ident">uninit</span>();
<span class="kw">let</span> <span class="ident">x_vec</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="kw-2">&amp;</span><span class="kw-2">*</span><span class="ident">x</span>.<span class="ident">as_ptr</span>() };
<span class="comment">// We have created a reference to an uninitialized vector! This is undefined behavior.</span></pre></div>
<p>(Notice that the rules around references to uninitialized data are not finalized yet, but
until they are, it is advisable to avoid them.)</p>
</div><h4 id='method.as_mut_ptr' class="method"><code id='as_mut_ptr.v'>pub fn <a href='#method.as_mut_ptr' class='fnname'>as_mut_ptr</a>(&amp;mut self) -&gt; *mut T</code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/mem/maybe_uninit.rs.html#447-449' title='goto source code'>[src]</a></h4><div class='docblock'><p>Gets a mutable pointer to the contained value. Reading from this pointer or turning it
into a reference is undefined behavior unless the <code>MaybeUninit&lt;T&gt;</code> is initialized.</p>
<h1 id="examples-3" class="section-header"><a href="#examples-3">Examples</a></h1>
<p>Correct usage of this method:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">mem</span>::<span class="ident">MaybeUninit</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">x</span> <span class="op">=</span> <span class="ident">MaybeUninit</span>::<span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span><span class="op">&gt;</span>::<span class="ident">uninit</span>();
<span class="kw">unsafe</span> { <span class="ident">x</span>.<span class="ident">as_mut_ptr</span>().<span class="ident">write</span>(<span class="macro">vec</span><span class="macro">!</span>[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]); }
<span class="comment">// Create a reference into the `MaybeUninit&lt;Vec&lt;u32&gt;&gt;`.</span>
<span class="comment">// This is okay because we initialized it.</span>
<span class="kw">let</span> <span class="ident">x_vec</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="kw-2">*</span><span class="ident">x</span>.<span class="ident">as_mut_ptr</span>() };
<span class="ident">x_vec</span>.<span class="ident">push</span>(<span class="number">3</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">x_vec</span>.<span class="ident">len</span>(), <span class="number">4</span>);</pre></div>
<p><em>Incorrect</em> usage of this method:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">mem</span>::<span class="ident">MaybeUninit</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">x</span> <span class="op">=</span> <span class="ident">MaybeUninit</span>::<span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span><span class="op">&gt;</span>::<span class="ident">uninit</span>();
<span class="kw">let</span> <span class="ident">x_vec</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="kw-2">*</span><span class="ident">x</span>.<span class="ident">as_mut_ptr</span>() };
<span class="comment">// We have created a reference to an uninitialized vector! This is undefined behavior.</span></pre></div>
<p>(Notice that the rules around references to uninitialized data are not finalized yet, but
until they are, it is advisable to avoid them.)</p>
</div><h4 id='method.assume_init' class="method"><code id='assume_init.v'>pub unsafe fn <a href='#method.assume_init' class='fnname'>assume_init</a>(self) -&gt; T</code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/mem/maybe_uninit.rs.html#497-500' title='goto source code'>[src]</a></h4><div class='docblock'><p>Extracts the value from the <code>MaybeUninit&lt;T&gt;</code> container. This is a great way
to ensure that the data will get dropped, because the resulting <code>T</code> is
subject to the usual drop handling.</p>
<h1 id="safety" class="section-header"><a href="#safety">Safety</a></h1>
<p>It is up to the caller to guarantee that the <code>MaybeUninit&lt;T&gt;</code> really is in an initialized
state. Calling this when the content is not yet fully initialized causes immediate undefined
behavior. The <a href="#initialization-invariant">type-level documentation</a> contains more information about
this initialization invariant.</p>
<p>On top of that, remember that most types have additional invariants beyond merely
being considered initialized at the type level. For example, a <code>1</code>-initialized [<code>Vec&lt;T&gt;</code>]
is considered initialized (under the current implementation; this does not constitute
a stable guarantee) because the only requirement the compiler knows about it
is that the data pointer must be non-null. Creating such a <code>Vec&lt;T&gt;</code> does not cause
<em>immediate</em> undefined behavior, but will cause undefined behavior with most
safe operations (including dropping it).</p>
<h1 id="examples-4" class="section-header"><a href="#examples-4">Examples</a></h1>
<p>Correct usage of this method:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">mem</span>::<span class="ident">MaybeUninit</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">x</span> <span class="op">=</span> <span class="ident">MaybeUninit</span>::<span class="op">&lt;</span><span class="ident">bool</span><span class="op">&gt;</span>::<span class="ident">uninit</span>();
<span class="kw">unsafe</span> { <span class="ident">x</span>.<span class="ident">as_mut_ptr</span>().<span class="ident">write</span>(<span class="bool-val">true</span>); }
<span class="kw">let</span> <span class="ident">x_init</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="ident">x</span>.<span class="ident">assume_init</span>() };
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">x_init</span>, <span class="bool-val">true</span>);</pre></div>
<p><em>Incorrect</em> usage of this method:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">mem</span>::<span class="ident">MaybeUninit</span>;

<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="ident">MaybeUninit</span>::<span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span><span class="op">&gt;</span>::<span class="ident">uninit</span>();
<span class="kw">let</span> <span class="ident">x_init</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="ident">x</span>.<span class="ident">assume_init</span>() };
<span class="comment">// `x` had not been initialized yet, so this last line caused undefined behavior.</span></pre></div>
</div><h4 id='method.read' class="method"><code id='read.v'>pub unsafe fn <a href='#method.read' class='fnname'>read</a>(&amp;self) -&gt; T</code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/mem/maybe_uninit.rs.html#561-564' title='goto source code'>[src]</a></h4><div class='stability'><div class='stab unstable'><span class='emoji'>🔬</span> This is a nightly-only experimental API. (<code>maybe_uninit_extra</code>)</div></div><div class='docblock'><p>Reads the value from the <code>MaybeUninit&lt;T&gt;</code> container. The resulting <code>T</code> is subject
to the usual drop handling.</p>
<p>Whenever possible, it is preferable to use <a href="#method.assume_init"><code>assume_init</code></a> instead, which
prevents duplicating the content of the <code>MaybeUninit&lt;T&gt;</code>.</p>
<h1 id="safety-1" class="section-header"><a href="#safety-1">Safety</a></h1>
<p>It is up to the caller to guarantee that the <code>MaybeUninit&lt;T&gt;</code> really is in an initialized
state. Calling this when the content is not yet fully initialized causes undefined
behavior. The <a href="#initialization-invariant">type-level documentation</a> contains more information about
this initialization invariant.</p>
<p>Moreover, this leaves a copy of the same data behind in the <code>MaybeUninit&lt;T&gt;</code>. When using
multiple copies of the data (by calling <code>read</code> multiple times, or first
calling <code>read</code> and then <a href="#method.assume_init"><code>assume_init</code></a>), it is your responsibility
to ensure that that data may indeed be duplicated.</p>
<h1 id="examples-5" class="section-header"><a href="#examples-5">Examples</a></h1>
<p>Correct usage of this method:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="attribute">#![<span class="ident">feature</span>(<span class="ident">maybe_uninit_extra</span>)]</span>
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">mem</span>::<span class="ident">MaybeUninit</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">x</span> <span class="op">=</span> <span class="ident">MaybeUninit</span>::<span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span>::<span class="ident">uninit</span>();
<span class="ident">x</span>.<span class="ident">write</span>(<span class="number">13</span>);
<span class="kw">let</span> <span class="ident">x1</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="ident">x</span>.<span class="ident">read</span>() };
<span class="comment">// `u32` is `Copy`, so we may read multiple times.</span>
<span class="kw">let</span> <span class="ident">x2</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="ident">x</span>.<span class="ident">read</span>() };
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">x1</span>, <span class="ident">x2</span>);

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">x</span> <span class="op">=</span> <span class="ident">MaybeUninit</span>::<span class="op">&lt;</span><span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span><span class="op">&gt;</span><span class="op">&gt;</span>::<span class="ident">uninit</span>();
<span class="ident">x</span>.<span class="ident">write</span>(<span class="prelude-val">None</span>);
<span class="kw">let</span> <span class="ident">x1</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="ident">x</span>.<span class="ident">read</span>() };
<span class="comment">// Duplicating a `None` value is okay, so we may read multiple times.</span>
<span class="kw">let</span> <span class="ident">x2</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="ident">x</span>.<span class="ident">read</span>() };
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">x1</span>, <span class="ident">x2</span>);</pre></div>
<p><em>Incorrect</em> usage of this method:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="attribute">#![<span class="ident">feature</span>(<span class="ident">maybe_uninit_extra</span>)]</span>
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">mem</span>::<span class="ident">MaybeUninit</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">x</span> <span class="op">=</span> <span class="ident">MaybeUninit</span>::<span class="op">&lt;</span><span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span><span class="op">&gt;</span><span class="op">&gt;</span>::<span class="ident">uninit</span>();
<span class="ident">x</span>.<span class="ident">write</span>(<span class="prelude-val">Some</span>(<span class="macro">vec</span><span class="macro">!</span>[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]));
<span class="kw">let</span> <span class="ident">x1</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="ident">x</span>.<span class="ident">read</span>() };
<span class="kw">let</span> <span class="ident">x2</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="ident">x</span>.<span class="ident">read</span>() };
<span class="comment">// We now created two copies of the same vector, leading to a double-free when</span>
<span class="comment">// they both get dropped!</span></pre></div>
</div><h4 id='method.get_ref' class="method"><code id='get_ref.v'>pub unsafe fn <a href='#method.get_ref' class='fnname'>get_ref</a>(&amp;self) -&gt; &amp;T</code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/mem/maybe_uninit.rs.html#623-626' title='goto source code'>[src]</a></h4><div class='stability'><div class='stab unstable'><span class='emoji'>🔬</span> This is a nightly-only experimental API. (<code>maybe_uninit_ref</code>)</div></div><div class='docblock'><p>Gets a shared reference to the contained value.</p>
<p>This can be useful when we want to access a <code>MaybeUninit</code> that has been
initialized but don't have ownership of the <code>MaybeUninit</code> (preventing the use
of <code>.assume_init()</code>).</p>
<h1 id="safety-2" class="section-header"><a href="#safety-2">Safety</a></h1>
<p>Calling this when the content is not yet fully initialized causes undefined
behavior: it is up to the caller to guarantee that the <code>MaybeUninit&lt;T&gt;</code> really
is in an initialized state.</p>
<h1 id="examples-6" class="section-header"><a href="#examples-6">Examples</a></h1><h3 id="correct-usage-of-this-method" class="section-header"><a href="#correct-usage-of-this-method">Correct usage of this method:</a></h3>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="attribute">#![<span class="ident">feature</span>(<span class="ident">maybe_uninit_ref</span>)]</span>
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">mem</span>::<span class="ident">MaybeUninit</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">x</span> <span class="op">=</span> <span class="ident">MaybeUninit</span>::<span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span><span class="op">&gt;</span>::<span class="ident">uninit</span>();
<span class="comment">// Initialize `x`:</span>
<span class="kw">unsafe</span> { <span class="ident">x</span>.<span class="ident">as_mut_ptr</span>().<span class="ident">write</span>(<span class="macro">vec</span><span class="macro">!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); }
<span class="comment">// Now that our `MaybeUninit&lt;_&gt;` is known to be initialized, it is okay to</span>
<span class="comment">// create a shared reference to it:</span>
<span class="kw">let</span> <span class="ident">x</span>: <span class="kw-2">&amp;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span> <span class="op">=</span> <span class="kw">unsafe</span> {
    <span class="comment">// Safety: `x` has been initialized.</span>
    <span class="ident">x</span>.<span class="ident">get_ref</span>()
};
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">x</span>, <span class="kw-2">&amp;</span><span class="macro">vec</span><span class="macro">!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</pre></div>
<h3 id="incorrect-usages-of-this-method" class="section-header"><a href="#incorrect-usages-of-this-method"><em>Incorrect</em> usages of this method:</a></h3>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="attribute">#![<span class="ident">feature</span>(<span class="ident">maybe_uninit_ref</span>)]</span>
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">mem</span>::<span class="ident">MaybeUninit</span>;

<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="ident">MaybeUninit</span>::<span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span><span class="op">&gt;</span>::<span class="ident">uninit</span>();
<span class="kw">let</span> <span class="ident">x_vec</span>: <span class="kw-2">&amp;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="ident">x</span>.<span class="ident">get_ref</span>() };
<span class="comment">// We have created a reference to an uninitialized vector! This is undefined behavior.</span></pre></div>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="attribute">#![<span class="ident">feature</span>(<span class="ident">maybe_uninit_ref</span>)]</span>
<span class="kw">use</span> <span class="ident">std</span>::{<span class="ident">cell</span>::<span class="ident">Cell</span>, <span class="ident">mem</span>::<span class="ident">MaybeUninit</span>};

<span class="kw">let</span> <span class="ident">b</span> <span class="op">=</span> <span class="ident">MaybeUninit</span>::<span class="op">&lt;</span><span class="ident">Cell</span><span class="op">&lt;</span><span class="ident">bool</span><span class="op">&gt;</span><span class="op">&gt;</span>::<span class="ident">uninit</span>();
<span class="comment">// Initialize the `MaybeUninit` using `Cell::set`:</span>
<span class="kw">unsafe</span> {
    <span class="ident">b</span>.<span class="ident">get_ref</span>().<span class="ident">set</span>(<span class="bool-val">true</span>);
 <span class="comment">// ^^^^^^^^^^^</span>
 <span class="comment">// Reference to an uninitialized `Cell&lt;bool&gt;`: UB!</span>
}</pre></div>
</div><h4 id='method.get_mut' class="method"><code id='get_mut.v'>pub unsafe fn <a href='#method.get_mut' class='fnname'>get_mut</a>(&amp;mut self) -&gt; &amp;mut T</code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/mem/maybe_uninit.rs.html#741-744' title='goto source code'>[src]</a></h4><div class='stability'><div class='stab unstable'><span class='emoji'>🔬</span> This is a nightly-only experimental API. (<code>maybe_uninit_ref</code>)</div></div><div class='docblock'><p>Gets a mutable (unique) reference to the contained value.</p>
<p>This can be useful when we want to access a <code>MaybeUninit</code> that has been
initialized but don't have ownership of the <code>MaybeUninit</code> (preventing the use
of <code>.assume_init()</code>).</p>
<h1 id="safety-3" class="section-header"><a href="#safety-3">Safety</a></h1>
<p>Calling this when the content is not yet fully initialized causes undefined
behavior: it is up to the caller to guarantee that the <code>MaybeUninit&lt;T&gt;</code> really
is in an initialized state. For instance, <code>.get_mut()</code> cannot be used to
initialize a <code>MaybeUninit</code>.</p>
<h1 id="examples-7" class="section-header"><a href="#examples-7">Examples</a></h1><h3 id="correct-usage-of-this-method-1" class="section-header"><a href="#correct-usage-of-this-method-1">Correct usage of this method:</a></h3>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="attribute">#![<span class="ident">feature</span>(<span class="ident">maybe_uninit_ref</span>)]</span>
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">mem</span>::<span class="ident">MaybeUninit</span>;

<span class="kw">extern</span> <span class="string">&quot;C&quot;</span> {
    <span class="doccomment">/// Initializes *all* the bytes of the input buffer.</span>
    <span class="kw">fn</span> <span class="ident">initialize_buffer</span>(<span class="ident">buf</span>: <span class="kw-2">*</span><span class="kw-2">mut</span> [<span class="ident">u8</span>; <span class="number">2048</span>]);
}

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">buf</span> <span class="op">=</span> <span class="ident">MaybeUninit</span>::<span class="op">&lt;</span>[<span class="ident">u8</span>; <span class="number">2048</span>]<span class="op">&gt;</span>::<span class="ident">uninit</span>();

<span class="comment">// Initialize `buf`:</span>
<span class="kw">unsafe</span> { <span class="ident">initialize_buffer</span>(<span class="ident">buf</span>.<span class="ident">as_mut_ptr</span>()); }
<span class="comment">// Now we know that `buf` has been initialized, so we could `.assume_init()` it.</span>
<span class="comment">// However, using `.assume_init()` may trigger a `memcpy` of the 2048 bytes.</span>
<span class="comment">// To assert our buffer has been initialized without copying it, we upgrade</span>
<span class="comment">// the `&amp;mut MaybeUninit&lt;[u8; 2048]&gt;` to a `&amp;mut [u8; 2048]`:</span>
<span class="kw">let</span> <span class="ident">buf</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> [<span class="ident">u8</span>; <span class="number">2048</span>] <span class="op">=</span> <span class="kw">unsafe</span> {
    <span class="comment">// Safety: `buf` has been initialized.</span>
    <span class="ident">buf</span>.<span class="ident">get_mut</span>()
};

<span class="comment">// Now we can use `buf` as a normal slice:</span>
<span class="ident">buf</span>.<span class="ident">sort_unstable</span>();
<span class="macro">assert</span><span class="macro">!</span>(
    <span class="ident">buf</span>.<span class="ident">windows</span>(<span class="number">2</span>).<span class="ident">all</span>(<span class="op">|</span><span class="ident">pair</span><span class="op">|</span> <span class="ident">pair</span>[<span class="number">0</span>] <span class="op">&lt;</span><span class="op">=</span> <span class="ident">pair</span>[<span class="number">1</span>]),
    <span class="string">&quot;buffer is sorted&quot;</span>,
);</pre></div>
<h3 id="incorrect-usages-of-this-method-1" class="section-header"><a href="#incorrect-usages-of-this-method-1"><em>Incorrect</em> usages of this method:</a></h3>
<p>You cannot use <code>.get_mut()</code> to initialize a value:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="attribute">#![<span class="ident">feature</span>(<span class="ident">maybe_uninit_ref</span>)]</span>
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">mem</span>::<span class="ident">MaybeUninit</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">b</span> <span class="op">=</span> <span class="ident">MaybeUninit</span>::<span class="op">&lt;</span><span class="ident">bool</span><span class="op">&gt;</span>::<span class="ident">uninit</span>();
<span class="kw">unsafe</span> {
    <span class="kw-2">*</span><span class="ident">b</span>.<span class="ident">get_mut</span>() <span class="op">=</span> <span class="bool-val">true</span>;
    <span class="comment">// We have created a (mutable) reference to an uninitialized `bool`!</span>
    <span class="comment">// This is undefined behavior.</span>
}</pre></div>
<p>For instance, you cannot <a href="https://doc.rust-lang.org/std/io/trait.Read.html"><code>Read</code></a> into an uninitialized buffer:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="attribute">#![<span class="ident">feature</span>(<span class="ident">maybe_uninit_ref</span>)]</span>
<span class="kw">use</span> <span class="ident">std</span>::{<span class="ident">io</span>, <span class="ident">mem</span>::<span class="ident">MaybeUninit</span>};

<span class="kw">fn</span> <span class="ident">read_chunk</span> (<span class="ident">reader</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;_</span> <span class="kw-2">mut</span> <span class="ident">dyn</span> <span class="ident">io</span>::<span class="ident">Read</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">io</span>::<span class="prelude-ty">Result</span><span class="op">&lt;</span>[<span class="ident">u8</span>; <span class="number">64</span>]<span class="op">&gt;</span>
{
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">buffer</span> <span class="op">=</span> <span class="ident">MaybeUninit</span>::<span class="op">&lt;</span>[<span class="ident">u8</span>; <span class="number">64</span>]<span class="op">&gt;</span>::<span class="ident">uninit</span>();
    <span class="ident">reader</span>.<span class="ident">read_exact</span>(<span class="kw">unsafe</span> { <span class="ident">buffer</span>.<span class="ident">get_mut</span>() })<span class="question-mark">?</span>;
                            <span class="comment">// ^^^^^^^^^^^^^^^^</span>
                            <span class="comment">// (mutable) reference to uninitialized memory!</span>
                            <span class="comment">// This is undefined behavior.</span>
    <span class="prelude-val">Ok</span>(<span class="kw">unsafe</span> { <span class="ident">buffer</span>.<span class="ident">assume_init</span>() })
}</pre></div>
<p>Nor can you use direct field access to do field-by-field gradual initialization:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="attribute">#![<span class="ident">feature</span>(<span class="ident">maybe_uninit_ref</span>)]</span>
<span class="kw">use</span> <span class="ident">std</span>::{<span class="ident">mem</span>::<span class="ident">MaybeUninit</span>, <span class="ident">ptr</span>};

<span class="kw">struct</span> <span class="ident">Foo</span> {
    <span class="ident">a</span>: <span class="ident">u32</span>,
    <span class="ident">b</span>: <span class="ident">u8</span>,
}

<span class="kw">let</span> <span class="ident">foo</span>: <span class="ident">Foo</span> <span class="op">=</span> <span class="kw">unsafe</span> {
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">foo</span> <span class="op">=</span> <span class="ident">MaybeUninit</span>::<span class="op">&lt;</span><span class="ident">Foo</span><span class="op">&gt;</span>::<span class="ident">uninit</span>();
    <span class="ident">ptr</span>::<span class="ident">write</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">foo</span>.<span class="ident">get_mut</span>().<span class="ident">a</span> <span class="kw">as</span> <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">u32</span>, <span class="number">1337</span>);
                 <span class="comment">// ^^^^^^^^^^^^^</span>
                 <span class="comment">// (mutable) reference to uninitialized memory!</span>
                 <span class="comment">// This is undefined behavior.</span>
    <span class="ident">ptr</span>::<span class="ident">write</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">foo</span>.<span class="ident">get_mut</span>().<span class="ident">b</span> <span class="kw">as</span> <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">u8</span>, <span class="number">42</span>);
                 <span class="comment">// ^^^^^^^^^^^^^</span>
                 <span class="comment">// (mutable) reference to uninitialized memory!</span>
                 <span class="comment">// This is undefined behavior.</span>
    <span class="ident">foo</span>.<span class="ident">assume_init</span>()
};</pre></div>
</div><h4 id='method.slice_get_ref' class="method"><code id='slice_get_ref.v'>pub unsafe fn <a href='#method.slice_get_ref' class='fnname'>slice_get_ref</a>(slice: &amp;[<a class="union" href="../maybe_uninit/union.MaybeUninit.html" title="union maybe_uninit::MaybeUninit">MaybeUninit</a>&lt;T&gt;]) -&gt; &amp;[T]</code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/mem/maybe_uninit.rs.html#755-757' title='goto source code'>[src]</a></h4><div class='stability'><div class='stab unstable'><span class='emoji'>🔬</span> This is a nightly-only experimental API. (<code>maybe_uninit_slice_assume_init</code>)</div></div><div class='docblock'><p>Assuming all the elements are initialized, get a slice to them.</p>
<h1 id="safety-4" class="section-header"><a href="#safety-4">Safety</a></h1>
<p>It is up to the caller to guarantee that the <code>MaybeUninit&lt;T&gt;</code> elements
really are in an initialized state.
Calling this when the content is not yet fully initialized causes undefined behavior.</p>
</div><h4 id='method.slice_get_mut' class="method"><code id='slice_get_mut.v'>pub unsafe fn <a href='#method.slice_get_mut' class='fnname'>slice_get_mut</a>(slice: &amp;mut [<a class="union" href="../maybe_uninit/union.MaybeUninit.html" title="union maybe_uninit::MaybeUninit">MaybeUninit</a>&lt;T&gt;]) -&gt; &amp;mut [T]</code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/mem/maybe_uninit.rs.html#768-770' title='goto source code'>[src]</a></h4><div class='stability'><div class='stab unstable'><span class='emoji'>🔬</span> This is a nightly-only experimental API. (<code>maybe_uninit_slice_assume_init</code>)</div></div><div class='docblock'><p>Assuming all the elements are initialized, get a mutable slice to them.</p>
<h1 id="safety-5" class="section-header"><a href="#safety-5">Safety</a></h1>
<p>It is up to the caller to guarantee that the <code>MaybeUninit&lt;T&gt;</code> elements
really are in an initialized state.
Calling this when the content is not yet fully initialized causes undefined behavior.</p>
</div><h4 id='method.first_ptr' class="method"><code id='first_ptr.v'>pub fn <a href='#method.first_ptr' class='fnname'>first_ptr</a>(this: &amp;[<a class="union" href="../maybe_uninit/union.MaybeUninit.html" title="union maybe_uninit::MaybeUninit">MaybeUninit</a>&lt;T&gt;]) -&gt; *const T</code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/mem/maybe_uninit.rs.html#775-777' title='goto source code'>[src]</a></h4><div class='stability'><div class='stab unstable'><span class='emoji'>🔬</span> This is a nightly-only experimental API. (<code>maybe_uninit_slice</code>)</div></div><div class='docblock'><p>Gets a pointer to the first element of the array.</p>
</div><h4 id='method.first_ptr_mut' class="method"><code id='first_ptr_mut.v'>pub fn <a href='#method.first_ptr_mut' class='fnname'>first_ptr_mut</a>(this: &amp;mut [<a class="union" href="../maybe_uninit/union.MaybeUninit.html" title="union maybe_uninit::MaybeUninit">MaybeUninit</a>&lt;T&gt;]) -&gt; *mut T</code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/mem/maybe_uninit.rs.html#782-784' title='goto source code'>[src]</a></h4><div class='stability'><div class='stab unstable'><span class='emoji'>🔬</span> This is a nightly-only experimental API. (<code>maybe_uninit_slice</code>)</div></div><div class='docblock'><p>Gets a mutable pointer to the first element of the array.</p>
</div></div><h2 id='implementations' class='small-section-header'>Trait Implementations<a href='#implementations' class='anchor'></a></h2><div id='implementations-list'><h3 id='impl-Clone' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="union" href="../maybe_uninit/union.MaybeUninit.html" title="union maybe_uninit::MaybeUninit">MaybeUninit</a>&lt;T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Copy.html" title="trait core::marker::Copy">Copy</a>,&nbsp;</span></code><a href='#impl-Clone' class='anchor'></a><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/mem/maybe_uninit.rs.html#229-235' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.clone' class="method hidden"><code id='clone.v'>fn <a href='https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#tymethod.clone' class='fnname'>clone</a>(&amp;self) -&gt; <a class="union" href="../maybe_uninit/union.MaybeUninit.html" title="union maybe_uninit::MaybeUninit">MaybeUninit</a>&lt;T&gt;</code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/mem/maybe_uninit.rs.html#231-234' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Returns a copy of the value. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#tymethod.clone">Read more</a></p>
</div><h4 id='method.clone_from' class="method hidden"><code id='clone_from.v'>fn <a href='https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from' class='fnname'>clone_from</a>(&amp;mut self, source: &amp;Self)</code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/clone.rs.html#131-133' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Performs copy-assignment from <code>source</code>. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from">Read more</a></p>
</div></div><h3 id='impl-Copy' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Copy.html" title="trait core::marker::Copy">Copy</a> for <a class="union" href="../maybe_uninit/union.MaybeUninit.html" title="union maybe_uninit::MaybeUninit">MaybeUninit</a>&lt;T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Copy.html" title="trait core::marker::Copy">Copy</a>,&nbsp;</span></code><a href='#impl-Copy' class='anchor'></a><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/mem/maybe_uninit.rs.html#221' title='goto source code'>[src]</a></h3><div class='impl-items'></div><h3 id='impl-Debug' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="union" href="../maybe_uninit/union.MaybeUninit.html" title="union maybe_uninit::MaybeUninit">MaybeUninit</a>&lt;T&gt;</code><a href='#impl-Debug' class='anchor'></a><span class='since' title='Stable since Rust version 1.41.0'>1.41.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/mem/maybe_uninit.rs.html#238-242' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.fmt' class="method hidden"><code id='fmt.v'>fn <a href='https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt' class='fnname'>fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;(), <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Error.html" title="struct core::fmt::Error">Error</a>&gt;</code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/mem/maybe_uninit.rs.html#239-241' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></p>
</div></div></div><h2 id='synthetic-implementations' class='small-section-header'>Auto Trait Implementations<a href='#synthetic-implementations' class='anchor'></a></h2><div id='synthetic-implementations-list'><h3 id='impl-Send' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="union" href="../maybe_uninit/union.MaybeUninit.html" title="union maybe_uninit::MaybeUninit">MaybeUninit</a>&lt;T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a>,&nbsp;</span></code><a href='#impl-Send' class='anchor'></a></h3><div class='impl-items'></div><h3 id='impl-Sync' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="union" href="../maybe_uninit/union.MaybeUninit.html" title="union maybe_uninit::MaybeUninit">MaybeUninit</a>&lt;T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a>,&nbsp;</span></code><a href='#impl-Sync' class='anchor'></a></h3><div class='impl-items'></div><h3 id='impl-Unpin' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="union" href="../maybe_uninit/union.MaybeUninit.html" title="union maybe_uninit::MaybeUninit">MaybeUninit</a>&lt;T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,&nbsp;</span></code><a href='#impl-Unpin' class='anchor'></a></h3><div class='impl-items'></div></div><h2 id='blanket-implementations' class='small-section-header'>Blanket Implementations<a href='#blanket-implementations' class='anchor'></a></h2><div id='blanket-implementations-list'><h3 id='impl-Any' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a href='#impl-Any' class='anchor'></a><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/any.rs.html#108-112' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.type_id' class="method hidden"><code id='type_id.v'>fn <a href='https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id' class='fnname'>type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/any.rs.html#109-111' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id">Read more</a></p>
</div></div><h3 id='impl-Borrow%3CT%3E' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a href='#impl-Borrow%3CT%3E' class='anchor'></a><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#213-217' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.borrow' class="method hidden"><code id='borrow.v'>fn <a href='https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow' class='fnname'>borrow</a>(&amp;self) -&gt; &amp;T</code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#214-216' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></p>
</div></div><h3 id='impl-BorrowMut%3CT%3E' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a href='#impl-BorrowMut%3CT%3E' class='anchor'></a><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#220-224' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.borrow_mut' class="method hidden"><code id='borrow_mut.v'>fn <a href='https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut' class='fnname'>borrow_mut</a>(&amp;mut self) -&gt; &amp;mut T</code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#221-223' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></p>
</div></div><h3 id='impl-From%3CT%3E' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</code><a href='#impl-From%3CT%3E' class='anchor'></a><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#564-568' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.from' class="method hidden"><code id='from.v'>fn <a href='https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from' class='fnname'>from</a>(t: T) -&gt; T</code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#565-567' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id='impl-Into%3CU%3E' class='impl'><code class='in-band'>impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,&nbsp;</span></code><a href='#impl-Into%3CU%3E' class='anchor'></a><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#553-560' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.into' class="method hidden"><code id='into.v'>fn <a href='https://doc.rust-lang.org/nightly/core/convert/trait.Into.html#tymethod.into' class='fnname'>into</a>(self) -&gt; U</code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#557-559' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id='impl-TryFrom%3CU%3E' class='impl'><code class='in-band'>impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,&nbsp;</span></code><a href='#impl-TryFrom%3CU%3E' class='anchor'></a><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#601-610' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='associatedtype.Error' class="type"><code id='Error.t'>type <a href='https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error' class="type">Error</a> = <a class="enum" href="https://doc.rust-lang.org/nightly/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></code></h4><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div><h4 id='method.try_from' class="method hidden"><code id='try_from.v'>fn <a href='https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#tymethod.try_from' class='fnname'>try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#607-609' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id='impl-TryInto%3CU%3E' class='impl'><code class='in-band'>impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,&nbsp;</span></code><a href='#impl-TryInto%3CU%3E' class='anchor'></a><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#587-596' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='associatedtype.Error-1' class="type"><code id='Error.t-1'>type <a href='https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#associatedtype.Error' class="type">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></code></h4><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div><h4 id='method.try_into' class="method hidden"><code id='try_into.v'>fn <a href='https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#tymethod.try_into' class='fnname'>try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#593-595' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div></div></section><section id="search" class="content hidden"></section><section class="footer"></section><script>window.rootPath = "../";window.currentCrate = "maybe_uninit";</script><script src="../aliases.js"></script><script src="../main.js"></script><script defer src="../search-index.js"></script></body></html>