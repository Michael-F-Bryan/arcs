initSidebarItems({"enum":[["ComponentEvent","Component storage events received from a `FlaggedStorage` or any storage that implements `Tracked`."]],"struct":[["AsyncDispatcher","Like, `Dispatcher` but works asynchronously."],["BitSet","A `BitSet` is a simple set designed to track which indices are placed into it."],["DenseVecStorage","Dense vector storage. Has a redirection 2-way table between entities and components, allowing to leave no gaps within the data."],["Dispatcher","The dispatcher struct, allowing systems to be executed in parallel."],["DispatcherBuilder","Builder for the [`Dispatcher`]."],["Entity","`Entity` type, as seen by the user."],["FlaggedStorage","Wrapper storage that tracks modifications, insertions, and removals of components through an `EventChannel`."],["HashMapStorage","`HashMap`-based storage. Best suited for rare components."],["LazyUpdate","Lazy updates can be used for world updates that need to borrow a lot of resources and as such should better be done at the end. They work lazily in the sense that they are dispatched when calling `world.maintain()`."],["NullStorage","A null storage type, used for cases where the component doesn't contain any data and instead works as a simple flag."],["Read","Allows to fetch a resource in a system immutably."],["ReaderId","A reader ID which represents a subscription to the events pushed to the `EventChannel`."],["ResourceId","The id of a [`Resource`], which simply wraps a type id and a \"dynamic ID\". The \"dynamic ID\" is usually just left `0`, and, unless such documentation says otherwise, other libraries will assume that it is always `0`; non-zero IDs are only used for special resource types that are specifically defined in a more dynamic way, such that resource types can essentially be created at run time, without having different static types."],["StaticAccessor","The static accessor that is used for `SystemData`."],["VecStorage","Vector storage. Uses a simple `Vec`. Supposed to have maximum performance for the components mostly present in entities."],["World","A [Resource] container, which provides methods to insert, access and manage the contained resources."],["Write","Allows to fetch a resource in a system mutably."]],"trait":[["Accessor","A trait for accessing read/write multiple resources from a system. This can be used to create dynamic systems that don't specify what they fetch at compile-time."],["Component","Abstract component type. Doesn't have to be Copy or even Clone."],["ParJoin","The purpose of the `ParJoin` trait is to provide a way to access multiple storages in parallel at the same time with the merged bit set."],["ParallelIterator","Parallel version of the standard iterator trait."],["Resource","A resource is a data slot which lives in the `World` can only be accessed according to Rust's typical borrowing model (one writer xor multiple readers)."],["RunNow","Trait for fetching data and running systems. Automatically implemented for systems."],["System","A `System`, executed with a set of required [`Resource`]s."],["SystemData","A static system data that can specify its dependencies at statically (at compile-time). Most system data is a `SystemData`, the `DynamicSystemData` type is only needed for very special setups."],["Tracked","`UnprotectedStorage`s that track modifications, insertions, and removals of components."],["WorldExt","This trait provides some extension methods to make working with shred's [World] easier."]],"type":[["Entities","A wrapper for a read `Entities` resource. Note that this is just `Read<Entities>`, so you can easily use it in your system:"],["ReadExpect","Allows to fetch a resource in a system immutably. This will panic if the resource does not exist. Usage of `Read` or `Option<Read>` is therefore recommended."],["ReadStorage","A storage with read access."],["WriteExpect","Allows to fetch a resource in a system mutably. This will panic if the resource does not exist. Usage of `Write` or `Option<Write>` is therefore recommended."],["WriteStorage","A storage with read and write access."]]});